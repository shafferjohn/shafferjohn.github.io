<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"shaffer.cn","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":5,"unescape":"enable","preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="线程安全的map众所周知，go中的map不是线程安全的，两个线程（或协程）同时修改map中同一个key的value，会产生不确定的结果。而在golang中，遇到这种情况，程序会panic退出，个人觉得这样严苛的限制可以迫使开发者明白自己在写什么，以免未来陷入排查并发问题的痛苦之中。 关于go开发者关于设计非并发安全的map的初衷可以看这里： Go maps in action Why are ma">
<meta property="og:type" content="article">
<meta property="og:title" content="golang 多种线程安全的map性能比较">
<meta property="og:url" content="https://shaffer.cn/golang/golang-map-benchmark/">
<meta property="og:site_name" content="朱晓峰">
<meta property="og:description" content="线程安全的map众所周知，go中的map不是线程安全的，两个线程（或协程）同时修改map中同一个key的value，会产生不确定的结果。而在golang中，遇到这种情况，程序会panic退出，个人觉得这样严苛的限制可以迫使开发者明白自己在写什么，以免未来陷入排查并发问题的痛苦之中。 关于go开发者关于设计非并发安全的map的初衷可以看这里： Go maps in action Why are ma">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://shaffer.cn/images/map_benchmark_set.png">
<meta property="og:image" content="https://shaffer.cn/images/map_benchmark_get.png">
<meta property="article:published_time" content="2020-05-12T11:32:00.000Z">
<meta property="article:modified_time" content="2024-07-06T17:19:51.366Z">
<meta property="article:author" content="Shaffer John">
<meta property="article:tag" content="golang">
<meta property="article:tag" content="map">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://shaffer.cn/images/map_benchmark_set.png">

<link rel="canonical" href="https://shaffer.cn/golang/golang-map-benchmark/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>golang 多种线程安全的map性能比较 | 朱晓峰</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">朱晓峰</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一只生之无趣死之乏味的丧家之犬</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-photography">

    <a href="/photography/" rel="section"><i class="fa fa-camera fa-fw"></i>Photography</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://shaffer.cn/golang/golang-map-benchmark/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="Shaffer John">
      <meta itemprop="description" content="一只生之无趣死之乏味的丧家之犬">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朱晓峰">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          golang 多种线程安全的map性能比较
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-05-12 19:32:00" itemprop="dateCreated datePublished" datetime="2020-05-12T19:32:00+08:00">2020-05-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2024-07-07 01:19:51" itemprop="dateModified" datetime="2024-07-07T01:19:51+08:00">2024-07-07</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang/" itemprop="url" rel="index"><span itemprop="name">golang</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="线程安全的map"><a href="#线程安全的map" class="headerlink" title="线程安全的map"></a>线程安全的map</h1><p>众所周知，go中的map不是线程安全的，两个线程（或协程）同时修改map中同一个key的value，会产生不确定的结果。而在golang中，遇到这种情况，程序会panic退出，个人觉得这样严苛的限制可以迫使开发者明白自己在写什么，以免未来陷入排查并发问题的痛苦之中。</p>
<p>关于go开发者关于设计非并发安全的map的初衷可以看这里：</p>
<p><a href="https://blog.golang.org/maps">Go maps in action</a></p>
<p><a href="https://golang.org/doc/faq#atomic_maps">Why are map operations not defined to be atomic?</a></p>
<p>目前运用比较广泛的有三种线程安全的map实现方法：</p>
<ul>
<li><p><code>sync.RWMutex + map</code> 组成<code>struct</code></p>
</li>
<li><p><a href="https://golang.org/pkg/sync/#Map">sync.Map</a></p>
</li>
<li><p>一个利用分段锁原理实现的map: <a href="https://github.com/orcaman/concurrent-map">concurrent-map</a></p>
</li>
</ul>
<span id="more"></span>

<h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><h4 id="测试环境"><a href="#测试环境" class="headerlink" title="测试环境"></a>测试环境</h4><p>测试平台：</p>
<table>
<thead>
<tr>
<th>硬件</th>
<th>配置</th>
</tr>
</thead>
<tbody><tr>
<td>CPU</td>
<td><code>i7-9700K 8C8T</code></td>
</tr>
<tr>
<td>RAM</td>
<td><code>32G</code></td>
</tr>
<tr>
<td>OS</td>
<td>Win10 专业工作站版</td>
</tr>
</tbody></table>
<p>go版本：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go version</span><br><span class="line">go version go1.14.2 windows/amd64</span><br></pre></td></tr></table></figure>

<h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ go test -bench=. -benchtime=3s -benchmem</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">BenchmarkMap_Set-8                  3681            967422 ns/op          159212 B/op      19901 allocs/op</span><br><span class="line">BenchmarkMap_Get-8                  4568            791230 ns/op           39614 B/op       9901 allocs/op</span><br><span class="line">BenchmarkMutexMap_Set-8             1164           3028656 ns/op          163996 B/op      19946 allocs/op</span><br><span class="line">BenchmarkMutexMap_Get-8             1735           2094115 ns/op           39895 B/op       9903 allocs/op</span><br><span class="line">BenchmarkSyncMap_Set-8              1022           3673158 ns/op          486904 B/op      39981 allocs/op</span><br><span class="line">BenchmarkSyncMap_Get-8              1562           2315195 ns/op           39908 B/op       9903 allocs/op</span><br><span class="line">BenchmarkConcurrentMap_Set-8        1346           2639138 ns/op          159914 B/op      19908 allocs/op</span><br><span class="line">BenchmarkConcurrentMap_Get-8        1528           2343214 ns/op           39799 B/op       9902 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      _/D_/projects/test/go/map/benchmark   30.852s</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h4><p>首先创建长度均为10000的<code>MutexMap</code>、<code>SyncMap</code>和<code>ConcurrentMap</code>三种并发安全的map，然后分别循环10000次的并发写入和并发读取，具体代码见下方。</p>
<p><code>BenchmarkMap_Set</code> 和 <code>BenchmarkMap_Get</code>是非并发安全的基准测试</p>
<p>上述结果表明单独并发写入的时候，<code>concurrent-map</code>形式的map性能最好，<code>mutex+map</code>次之，<code>sync.Map</code>排在最后。</p>
<blockquote>
<p><del>比较反直觉的是，为什么利用分段锁原理实现的<code>concurrent-map</code>性能还不如一整把大锁的<code>mutex+map</code>。理论上来说，并发性能应该随着分段锁数量的增长而增长。</del></p>
</blockquote>
<p>上述被删除的话是因为之前benchmark代码写错了而导致的错误结论，具体原因是由于<code>concurrent-map</code>库实现的时候底层结构是<code>map[string]interface&#123;&#125;</code>，而我在与之比较的<code>mutex+map</code>用的却是<code>map[string]int</code></p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/orcaman/concurrent-map&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> N = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> simpleMap <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> mutexMap MutexMap</span><br><span class="line"><span class="keyword">var</span> syncMap sync.Map</span><br><span class="line"><span class="keyword">var</span> concurrentMap cmap.ConcurrentMap</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	simpleMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;, N)</span><br><span class="line">	mutexMap = MutexMap&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;, N)&#125;</span><br><span class="line">	syncMap = sync.Map&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;N; i++ &#123;</span><br><span class="line">		syncMap.Store(strconv.Itoa(i), i)</span><br><span class="line">	&#125;</span><br><span class="line">	concurrentMap = cmap.New()</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;N; i++ &#123;</span><br><span class="line">		concurrentMap.Set(strconv.Itoa(i), i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMap_Set</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;b.N; i++ &#123;</span><br><span class="line">		wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">		wg.Add(N)</span><br><span class="line">		<span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;N; j++ &#123;</span><br><span class="line">			idx := rand.Intn(N)</span><br><span class="line">			simpleMap[strconv.Itoa(idx)] = j + <span class="number">1</span></span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMap_Get</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;b.N; i++ &#123;</span><br><span class="line">		wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">		wg.Add(N)</span><br><span class="line">		<span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;N; j++ &#123;</span><br><span class="line">			idx := rand.Intn(N)</span><br><span class="line">			_ = simpleMap[strconv.Itoa(idx)]</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMutexMap_Set</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;b.N; i++ &#123;</span><br><span class="line">		wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">		wg.Add(N)</span><br><span class="line">		<span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;N; j++ &#123;</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				idx := rand.Intn(N)</span><br><span class="line">				mutexMap.Set(strconv.Itoa(idx), j+<span class="number">1</span>)</span><br><span class="line">				wg.Done()</span><br><span class="line">			&#125;()</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMutexMap_Get</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;b.N; i++ &#123;</span><br><span class="line">		wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">		wg.Add(N)</span><br><span class="line">		<span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;N; j++ &#123;</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				idx := rand.Intn(N)</span><br><span class="line">				mutexMap.Get(strconv.Itoa(idx))</span><br><span class="line">				wg.Done()</span><br><span class="line">			&#125;()</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSyncMap_Set</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;b.N; i++ &#123;</span><br><span class="line">		wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">		wg.Add(N)</span><br><span class="line">		<span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;N; j++ &#123;</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				idx := rand.Intn(N)</span><br><span class="line">				syncMap.Store(strconv.Itoa(idx), j+<span class="number">1</span>)</span><br><span class="line">				wg.Done()</span><br><span class="line">			&#125;()</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSyncMap_Get</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;b.N; i++ &#123;</span><br><span class="line">		wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">		wg.Add(N)</span><br><span class="line">		<span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;N; j++ &#123;</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				idx := rand.Intn(N)</span><br><span class="line">				syncMap.Load(strconv.Itoa(idx))</span><br><span class="line">				wg.Done()</span><br><span class="line">			&#125;()</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcurrentMap_Set</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;b.N; i++ &#123;</span><br><span class="line">		wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">		wg.Add(N)</span><br><span class="line">		<span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;N; j++ &#123;</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				idx := rand.Intn(N)</span><br><span class="line">				concurrentMap.Set(strconv.Itoa(idx), j+<span class="number">1</span>)</span><br><span class="line">				wg.Done()</span><br><span class="line">			&#125;()</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcurrentMap_Get</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>; i&lt;b.N; i++ &#123;</span><br><span class="line">		wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">		wg.Add(N)</span><br><span class="line">		<span class="keyword">for</span> j:=<span class="number">0</span>; j&lt;N; j++ &#123;</span><br><span class="line">			<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">				idx := rand.Intn(N)</span><br><span class="line">				concurrentMap.Get(strconv.Itoa(idx))</span><br><span class="line">				wg.Done()</span><br><span class="line">			&#125;()</span><br><span class="line">		&#125;</span><br><span class="line">		wg.Wait()</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MutexMap <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.RWMutex</span><br><span class="line">	m <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexMap)</span></span> Set(k <span class="type">string</span>, v <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	m.Lock()</span><br><span class="line">	m.m[k] = v</span><br><span class="line">	m.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexMap)</span></span> Get(k <span class="type">string</span>) (v <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	m.RLock()</span><br><span class="line">	v = m.m[k]</span><br><span class="line">	m.RUnlock()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="进阶分析"><a href="#进阶分析" class="headerlink" title="进阶分析"></a>进阶分析</h3><p><code>mutex+map</code>这种并发安全的map实现方式简单来说，就是在整个map上加了一把大锁。</p>
<p>而<code>concurrent-map</code>和java的<code>ConcurrentHashMap</code>整体思路大致相同，都是分段锁，减小锁的粒度换来更高并发性能的思想。</p>
<p>理论上，分成两段锁的map写入性能应该是一把大锁的map的两倍，但实际情况，还需要考虑寻找分段时的损耗以及上下文的切换。</p>
<p>下面我简单实现了一下分段锁的map，并测试了一下不同分段数量下的性能比较。</p>
<p><code>main.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> PRIME32 = <span class="type">uint32</span>(<span class="number">16777619</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConcurrentMap <span class="keyword">struct</span> &#123;</span><br><span class="line">	ShardCount <span class="type">int</span></span><br><span class="line">	items []*ConcurrentMapShard</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConcurrentMapShard <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.RWMutex</span><br><span class="line">	m <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(log2OfShardCount <span class="type">int</span>)</span></span> ConcurrentMap &#123;</span><br><span class="line">	shardCount := <span class="number">1</span>&lt;&lt;log2OfShardCount</span><br><span class="line">	m := ConcurrentMap&#123;</span><br><span class="line">		ShardCount: shardCount,</span><br><span class="line">		items:      <span class="built_in">make</span>([]*ConcurrentMapShard, shardCount),</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; shardCount; i++ &#123;</span><br><span class="line">		m.items[i] = &amp;ConcurrentMapShard&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;)&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m ConcurrentMap)</span></span> GetShard(key <span class="type">string</span>) *ConcurrentMapShard &#123;</span><br><span class="line">	<span class="keyword">return</span> m.items[<span class="type">uint</span>(fnv32(key)) &amp; <span class="type">uint</span>(m.ShardCount<span class="number">-1</span>)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m ConcurrentMap)</span></span> Set(key <span class="type">string</span>, value <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	shard := m.GetShard(key)</span><br><span class="line">	shard.Lock()</span><br><span class="line">	shard.m[key] = value</span><br><span class="line">	shard.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m ConcurrentMap)</span></span> Get(key <span class="type">string</span>) (<span class="keyword">interface</span>&#123;&#125;, <span class="type">bool</span>) &#123;</span><br><span class="line">	shard := m.GetShard(key)</span><br><span class="line">	shard.RLock()</span><br><span class="line">	val, ok := shard.m[key]</span><br><span class="line">	shard.RUnlock()</span><br><span class="line">	<span class="keyword">return</span> val, ok</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fnv32</span><span class="params">(key <span class="type">string</span>)</span></span> <span class="type">uint32</span> &#123;</span><br><span class="line">	hash := <span class="type">uint32</span>(<span class="number">2166136261</span>)</span><br><span class="line">	length := <span class="built_in">len</span>(key)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; length; i++ &#123;</span><br><span class="line">		hash *= PRIME32</span><br><span class="line">		hash ^= <span class="type">uint32</span>(key[i])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> hash</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>New(log2OfShardCount int)</code>表示创建的段数为2的幂，是为了上篇文章<a href="https://shaffer.cn/golang/golang-map-touch/">golang map 实现原理初探</a>中提到的性能优化方式：<code>n mod m = n &amp; (m - 1)</code></p>
<p>主要测试逻辑是，创建长度为10000的各种map，然后每个goroutine读或写100次map</p>
<h4 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h4><p>实验环境同上</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ go test -bench=. -benchmem</span><br><span class="line">goos: windows</span><br><span class="line">goarch: amd64</span><br><span class="line">BenchmarkMap_Set-8                        169460              6822 ns/op            1592 B/op        199 allocs/op</span><br><span class="line">BenchmarkMap_Get-8                        227022              5354 ns/op             388 B/op         99 allocs/op</span><br><span class="line">BenchmarkMutexMap_Set-8                    49311             27208 ns/op            2037 B/op        201 allocs/op</span><br><span class="line">BenchmarkMutexMap_Get-8                   245551              6101 ns/op             702 B/op        100 allocs/op</span><br><span class="line">BenchmarkSyncMap_Set-8                     45951             29188 ns/op            4871 B/op        400 allocs/op</span><br><span class="line">BenchmarkSyncMap_Get-8                   1000000              1411 ns/op             380 B/op         67 allocs/op</span><br><span class="line">BenchmarkConcurrentMap2_Set-8              59857             22799 ns/op            1688 B/op        200 allocs/op</span><br><span class="line">BenchmarkConcurrentMap2_Get-8             256150              5159 ns/op             399 B/op         99 allocs/op</span><br><span class="line">BenchmarkConcurrentMap4_Set-8              92553             13020 ns/op            1678 B/op        200 allocs/op</span><br><span class="line">BenchmarkConcurrentMap4_Get-8             376006              3255 ns/op             382 B/op         99 allocs/op</span><br><span class="line">BenchmarkConcurrentMap8_Set-8             150399              8531 ns/op            1653 B/op        200 allocs/op</span><br><span class="line">BenchmarkConcurrentMap8_Get-8             501336              2453 ns/op             398 B/op         99 allocs/op</span><br><span class="line">BenchmarkConcurrentMap16_Set-8            250670              5453 ns/op            1648 B/op        200 allocs/op</span><br><span class="line">BenchmarkConcurrentMap16_Get-8            668452              1998 ns/op             425 B/op         99 allocs/op</span><br><span class="line">BenchmarkConcurrentMap32_Set-8            364605              4146 ns/op            1626 B/op        200 allocs/op</span><br><span class="line">BenchmarkConcurrentMap32_Get-8            859450              1661 ns/op             395 B/op         99 allocs/op</span><br><span class="line">BenchmarkConcurrentMap64_Set-8            462778              3510 ns/op            1667 B/op        200 allocs/op</span><br><span class="line">BenchmarkConcurrentMap64_Get-8           1000000              1576 ns/op             276 B/op         58 allocs/op</span><br><span class="line">BenchmarkConcurrentMap128_Set-8           534606              3207 ns/op            1671 B/op        200 allocs/op</span><br><span class="line">BenchmarkConcurrentMap128_Get-8          1000000              1114 ns/op             151 B/op         32 allocs/op</span><br><span class="line">BenchmarkConcurrentMap256_Set-8           634191              3317 ns/op            1668 B/op        200 allocs/op</span><br><span class="line">BenchmarkConcurrentMap256_Get-8          1257463              1340 ns/op             416 B/op         99 allocs/op</span><br><span class="line">BenchmarkConcurrentMap512_Set-8           753351              2935 ns/op            1672 B/op        200 allocs/op</span><br><span class="line">BenchmarkConcurrentMap512_Get-8          1340647              1228 ns/op             374 B/op         99 allocs/op</span><br><span class="line">BenchmarkConcurrentMap1024_Set-8          752020              2745 ns/op            1667 B/op        200 allocs/op</span><br><span class="line">BenchmarkConcurrentMap1024_Get-8         1336896              1304 ns/op             400 B/op         99 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      _/D_/projects/test/go/map/benchmark   50.026s</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="结果分析-1"><a href="#结果分析-1" class="headerlink" title="结果分析"></a>结果分析</h4><p><img src="/images/map_benchmark_set.png" alt="并发安全map实现 set数据 性能比较"></p>
<p><img src="/images/map_benchmark_get.png" alt="并发安全map实现 get数据 性能比较"></p>
<p><code>sync.Map</code>的读取性能是<code>MutexMap</code>4.3倍，正如文档里所说的：</p>
<blockquote>
<p>The Map type is optimized for two common use cases: (1) when the entry for a given key is only ever written once but read many times, as in caches that only grow, or (2) when multiple goroutines read, write, and overwrite entries for disjoint sets of keys. In these two cases, use of a Map may significantly reduce lock contention compared to a Go map paired with a separate Mutex or RWMutex.</p>
</blockquote>
<p>主要适用于两个常见场景：</p>
<ul>
<li><p>读多写少</p>
</li>
<li><p>多goroutine读、写、复写完全不同的key</p>
</li>
</ul>
<p>从实验结果可以看出来，使用了分段锁的map有很大的读写性能提升。</p>
<p>但是和理论上的性能提升还有很大差距，而且分段数量也并不是越多越好。</p>
<p>所以当我们在设计高并发性能的程序时，需要权衡并发带来的性能提升和并发导致的开销。</p>
<h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><p><code>main_test.go</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;github.com/orcaman/concurrent-map&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;sync&quot;</span></span><br><span class="line">	<span class="string">&quot;testing&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> N = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> simpleMap <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> mutexMap MutexMap</span><br><span class="line"><span class="keyword">var</span> syncMap sync.Map</span><br><span class="line"><span class="keyword">var</span> concurrentMap cmap.ConcurrentMap</span><br><span class="line"><span class="keyword">var</span> concurrentMap2 ConcurrentMap</span><br><span class="line"><span class="keyword">var</span> concurrentMap4 ConcurrentMap</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MutexMap <span class="keyword">struct</span> &#123;</span><br><span class="line">	sync.RWMutex</span><br><span class="line">	m <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexMap)</span></span> Set(k <span class="type">string</span>, v <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	m.Lock()</span><br><span class="line">	m.m[k] = v</span><br><span class="line">	m.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *MutexMap)</span></span> Get(k <span class="type">string</span>) (v <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	m.RLock()</span><br><span class="line">	v = m.m[k]</span><br><span class="line">	m.RUnlock()</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	simpleMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;, N)</span><br><span class="line">	mutexMap = MutexMap&#123;m: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;, N)&#125;</span><br><span class="line">	syncMap = sync.Map&#123;&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">		syncMap.Store(strconv.Itoa(i), i)</span><br><span class="line">	&#125;</span><br><span class="line">	concurrentMap = cmap.New()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">		concurrentMap.Set(strconv.Itoa(i), i)</span><br><span class="line">	&#125;</span><br><span class="line">	concurrentMap2 = New(<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">		concurrentMap2.Set(strconv.Itoa(i), i)</span><br><span class="line">	&#125;</span><br><span class="line">	concurrentMap4 = New(<span class="number">2</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; N; i++ &#123;</span><br><span class="line">		concurrentMap4.Set(strconv.Itoa(i), i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMap_Set</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	finished := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, b.N)</span><br><span class="line"></span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100</span>; j++ &#123;</span><br><span class="line">			simpleMap[strconv.Itoa((i+j)%N)] = i</span><br><span class="line">		&#125;</span><br><span class="line">		finished &lt;- <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		&lt;- finished</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMap_Get</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	finished := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, b.N)</span><br><span class="line"></span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100</span>; j++ &#123;</span><br><span class="line">			_ = simpleMap[strconv.Itoa((i+j)%N)]</span><br><span class="line">		&#125;</span><br><span class="line">		finished &lt;- <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		&lt;- finished</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMutexMap_Set</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	finished := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, b.N)</span><br><span class="line"></span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100</span>; j++ &#123;</span><br><span class="line">				mutexMap.Set(strconv.Itoa((i+j)%N), i)</span><br><span class="line">			&#125;</span><br><span class="line">			finished &lt;- <span class="literal">true</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		&lt;- finished</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkMutexMap_Get</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	finished := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, b.N)</span><br><span class="line"></span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100</span>; j++ &#123;</span><br><span class="line">				mutexMap.Get(strconv.Itoa((i+j)%N))</span><br><span class="line">			&#125;</span><br><span class="line">			finished &lt;- <span class="literal">true</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		&lt;- finished</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSyncMap_Set</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	finished := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, b.N)</span><br><span class="line"></span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100</span>; j++ &#123;</span><br><span class="line">				syncMap.Store(strconv.Itoa((i+j)%N), i)</span><br><span class="line">			&#125;</span><br><span class="line">			finished &lt;- <span class="literal">true</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		&lt;- finished</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkSyncMap_Get</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	finished := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, b.N)</span><br><span class="line"></span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100</span>; j++ &#123;</span><br><span class="line">				syncMap.Load(strconv.Itoa((i+j)%N))</span><br><span class="line">			&#125;</span><br><span class="line">			finished &lt;- <span class="literal">true</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		&lt;- finished</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcurrentMap2_Set</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	finished := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, b.N)</span><br><span class="line"></span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100</span>; j++ &#123;</span><br><span class="line">				concurrentMap2.Set(strconv.Itoa((i+j)%N), i)</span><br><span class="line">			&#125;</span><br><span class="line">			finished &lt;- <span class="literal">true</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		&lt;- finished</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcurrentMap2_Get</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	finished := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, b.N)</span><br><span class="line"></span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100</span>; j++ &#123;</span><br><span class="line">				concurrentMap2.Get(strconv.Itoa((i+j)%N))</span><br><span class="line">			&#125;</span><br><span class="line">			finished &lt;- <span class="literal">true</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		&lt;- finished</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcurrentMap4_Set</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	finished := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, b.N)</span><br><span class="line"></span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100</span>; j++ &#123;</span><br><span class="line">				concurrentMap4.Set(strconv.Itoa((i+j)%N), i)</span><br><span class="line">			&#125;</span><br><span class="line">			finished &lt;- <span class="literal">true</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		&lt;- finished</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkConcurrentMap4_Get</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line">	finished := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">bool</span>, b.N)</span><br><span class="line"></span><br><span class="line">	b.ResetTimer()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">100</span>; j++ &#123;</span><br><span class="line">				concurrentMap4.Get(strconv.Itoa((i+j)%N))</span><br><span class="line">			&#125;</span><br><span class="line">			finished &lt;- <span class="literal">true</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">		&lt;- finished</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更多分段数量map的benchmark函数可以自己写了，这里就不赘述了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>benchmark如有错误或不妥的地方，请大家不吝赐教！</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/golang/" rel="tag"># golang</a>
              <a href="/tags/map/" rel="tag"># map</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/algorithm/algorithm-training-leetcode-151-reverse-words-in-a-string/" rel="prev" title="[算法训练]LeetCode 151: 翻转字符串里的单词">
      <i class="fa fa-chevron-left"></i> [算法训练]LeetCode 151: 翻转字符串里的单词
    </a></div>
      <div class="post-nav-item">
    <a href="/golang/golang-goroutine-schedule/" rel="next" title="Goroutine 调度浅析">
      Goroutine 调度浅析 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84map"><span class="nav-number">1.</span> <span class="nav-text">线程安全的map</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83"><span class="nav-number">1.0.1.</span> <span class="nav-text">性能比较</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83"><span class="nav-number">1.0.1.1.</span> <span class="nav-text">测试环境</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E7%BB%93%E6%9E%9C"><span class="nav-number">1.0.1.2.</span> <span class="nav-text">测试结果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90"><span class="nav-number">1.0.1.3.</span> <span class="nav-text">结果分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81"><span class="nav-number">1.0.1.4.</span> <span class="nav-text">代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E9%98%B6%E5%88%86%E6%9E%90"><span class="nav-number">1.0.2.</span> <span class="nav-text">进阶分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C"><span class="nav-number">1.0.2.1.</span> <span class="nav-text">实验结果</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%93%E6%9E%9C%E5%88%86%E6%9E%90-1"><span class="nav-number">1.0.2.2.</span> <span class="nav-text">结果分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="nav-number">1.0.2.3.</span> <span class="nav-text">代码</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Shaffer John"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Shaffer John</p>
  <div class="site-description" itemprop="description">一只生之无趣死之乏味的丧家之犬</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">24</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/shafferjohn" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;shafferjohn" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:www.pig2@qq.com" title="E-Mail → mailto:www.pig2@qq.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Shaffer John</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>






  <script src="//code.tidio.co/di5rmcmowqnqky0stgnzo1e7t7imyexz.js"></script>







  

  

</body>
</html>
